{"version":3,"sources":["utils/Gis.js","components/map-view/MapView.js","services/TimeFormatter.js","services/TimeService.js","components/route-details-view/RouteDetailsView.js","components/route-chooser-popup/RouteChooserPopup.js","components/loading-popup/LoadingPopup.js","services/OnTransitService.js","services/LocationTracker.js","components/end-of-route-popup/EndOfRoutePopup.js","components/app/App.js","index.js"],"names":["module","exports","EARTH_RADIUS","convertDegreesToRadians","degrees","Math","PI","convertRadiansToDegrees","radians","computeBearings","lat1","long1","lat2","long2","y","sin","cos","x","bearingInRadans","atan2","this","calculateDestinationPoint","lat","long","bearing","distance","latInRads","longInRads","angularDistance","bearingInRads","lat2InRads","asin","lat2InDegrees","long2InRads","calculateDistance","dLat","dLong","lat1_rads","lat2_rads","a","pow","c","sqrt","MapView","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","createStopsLayer","stopsStyle","OlStyle","image","OlCircleStyle","radius","fill","stroke","Stroke","color","width","OlVectorLayer","source","OlVectorSource","style","feature","updateStopsLayer","newStops","geoJsonObject","type","crs","properties","name","features","map","item","geometry","coordinates","fromLonLat","olStopsLayer","getSource","clear","addFeatures","OlGeoJSON","readFeatures","refresh","createPathLayer","pathStyle","OlStroke","updatePathLayer","newPath","olPathLayer","addFeature","readFeature","createLiveLocationLayer","liveLocationStyle","updateLiveLocationLayer","newLatitude","newLongitude","olLiveLocationLayer","olMap","initialLatitude","viewLocation","latitude","initialLongitude","longitude","mapZoom","zoom","olView","OlView","center","console","log","OlMap","target","layers","OlTileLayer","OlOSM","loadTilesWhileAnimating","view","nextProps","nextState","updateDimensions","newViewOptions","duration","animate","path","stops","curLatitude","currentLocation","curLongitude","_this2","setTimeout","updateSize","react_default","createElement","id","className","React","Component","getFormattedTime","numSeconds","numHrsRemaining","trunc","numMinRemaining","remainingTimeValue","remainingTimeUnit","toString","padStart","value","unit","getTimeInSeconds","dateObject","numHrsFromMidnight","getHours","numMinFromHr","getMinutes","getSeconds","getCurrentTime","Date","RouteDetailsView","state","prevTime","timer","setInterval","numSecAfterMidnight","updatedStops","filter","time","objectSpread","remainingTimeInSeconds","setState","prevState","clearInterval","_this3","stopContainers","formattedRemainingTime","alarmClassName","undefined","alarms","ID","key","onClick","e","addNewAlarmHandler","removeAlarmHandler","tripShortName","tripLongName","NearbyTripsChooserPopup","handleSubmit","event","preventDefault","route","selectedTripID","onSelectRoute","areThereRoutes","routes","length","rows","index","shortName","longName","headsign","display","trim","sort","tripA","tripB","trip","startTime","endTime","tripID","onSubmit","LoadingPopup","Axios","defaults","timeout","OnTransitService","options","params","get","rawData","data","url","TRIP_DETAILS_URL","GIS","require","predictLocation","startPathIndex","endPathIndex","ratio","distanceToTravel","startIndex","endIndex","totalDistance","i","curPathLocation","nextPathLocation","computeTotalDistanceBetweenPath","closestPathIndex","curDistance","closestPath","nextPath","getNearestPathLocation","location","curIndex","minIndex","maxIndex","minDistance","Infinity","GetLocationOnPath","adjacentStopIndexes","left","right","mid","floor","nextMid","stopA","stopB","Error","findBoundaryBetweenTwoStops","leftStop","rightStop","EndOfRoutePopup","countdownValue","countdownInterval","restartApp","App","displayLoadingSign","displayRouteChoices","displayRouteDetails","displayEndOfRouteMessage","curLocation","initLocation","possibleRoutes","tripDetailsID","tripDetails","componentWillUnmount","componentDidMount","startGeolocationWatch","geolocationOptions","enableHighAccuracy","maximumAge","navigator","geolocation","geolocationWatch","watchPosition","onLocationChangedSuccess","onLocationChangedError","startPredictedLocationWatch","liveLocationWatch","currentTimeInSeconds","predictedLocation","startAlarmWatch","alarmInterval","curTimeInSeconds","keys","forEach","stopID","stopDetails","find","stop","alarmDetails","minRemainingTimeLeft","isDispatched","dispatchAlarm","removeAlarm","stopAlarmWatch","stopLiveLocationWatch","stopGeolocationWatch","clearWatch","position","coords","accuracy","toLocaleTimeString","nearbyTripsPromise","onTransitService","getNearbyTrips","nearbyVehiclesPromise","getNearbyVehicles","Promise","all","then","values","tripIDs","nearbyTrips","catch","errors","error","selectRoute","getTripDetails","results","sumOfAllPathLatitudes","reduce","curSum","sumOfAllPathLongitudes","midPathLatitude","midPathLongitude","addNewAlarm","newAlarms","toastMessage","toast","POSITION","BOTTOM_CENTER","dispatchNotification","message","timeBeforeClosingNotification","Notification","requestPermission","permission","notification","close","formattedTimeRemaining","notificationContent","MockedOnTransitService","window","alert","components_route_details_view_RouteDetailsView","components_map_view_MapView","route_chooser_popup_RouteChooserPopup","end_of_route_popup_EndOfRoutePopup","components_loading_popup_LoadingPopup","lib","ReactDOM","render","components_app_App","document","getElementById"],"mappings":"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","file":"static/js/main.1a0a26c2.chunk.js","sourcesContent":["/**\n * A library used to perform GPS location calculations\n */\nmodule.exports = {\n    EARTH_RADIUS: 6371000, // in meters\n\n    /**\n     * Converts an angle from degrees to radians\n     * @param {Float} degrees Angle in degrees\n     * @returns {Float} Angle in radians\n     */\n    convertDegreesToRadians: function(degrees){\n        return degrees * Math.PI / 180;\n    },\n\n    /**\n     * Converts an angle from radians to degrees\n     * @param {Float} radians Angle in radians\n     * @returns {Float} Angle in degrees\n     */\n    convertRadiansToDegrees: function(radians){\n        return (radians * 180) / Math.PI;\n    },\n\n    /**\n     * Computes the bearing from the first GPS location to the last GPS location in degrees\n     * @param {Float} lat1 The latitude of the first GPS location in degrees\n     * @param {Float} long1 The longitude of the first GPS location in degrees\n     * @param {Float} lat2 The latitude of the last GPS location in degrees\n     * @param {Float} long2 The longitude of the last GPS location in degrees\n     * @returns {Float} The bearing from the first GPS location to the last GPS location.\n     */\n    computeBearings: function(lat1, long1, lat2, long2){\n        let y = Math.sin(long2 - long1) * Math.cos(lat2);\n        let x = (Math.cos(lat1) * Math.sin(lat2)) - \n                (Math.sin(lat1) * Math.cos(lat2) * Math.cos(long2 - long1));\n        let bearingInRadans = Math.atan2(y, x);\n        let bearingInDegrees = this.convertRadiansToDegrees(bearingInRadans);\n        return (bearingInDegrees + 180) % 360;\n    },\n\n    /**\n     * Calculates the approximate location X distance away from a GPS location with a \n     * certain bearing from that GPS location.\n     * \n     * It will return an object with the following structure:\n     * {\n     *      lat: <latitude of approximate location>\n     *      long: <longitude of approximate location>\n     * }\n     * \n     * @param {Float} lat The latitude of the GPS location in degrees\n     * @param {Float} long The longitude of the GPS location in degrees\n     * @param {Float} bearing The bearing in degrees\n     * @param {Float} distance The distance in meters\n     * @returns {Object} The approximate location.\n     */\n    calculateDestinationPoint: function(lat, long, bearing, distance){\n        let latInRads = this.convertDegreesToRadians(lat);\n        let longInRads = this.convertDegreesToRadians(long);\n\n        let angularDistance = distance / this.EARTH_RADIUS;\n        let bearingInRads = this.convertDegreesToRadians(bearing);\n\n        let lat2InRads = Math.asin(Math.sin(latInRads) * Math.cos(angularDistance) + \n                        Math.cos(latInRads) * Math.sin(angularDistance) * Math.cos(bearingInRads));\n        let lat2InDegrees = this.convertRadiansToDegrees(lat2InRads);\n\n        let y = Math.sin(bearingInRads) * Math.sin(angularDistance) * Math.cos(latInRads);\n        let x = Math.cos(angularDistance) - Math.sin(latInRads) * Math.sin(lat2InRads);\n        let long2InRads = longInRads + Math.atan2(y, x);\n        \n        \n        let long2InDegrees = this.convertRadiansToDegrees(long2InRads);\n        let normalizedLong2InDegrees = (long2InDegrees + 540) % 360 - 180;\n        \n        return {\n            lat: lat2InDegrees,\n            long: normalizedLong2InDegrees\n        };\n    },\n\n    /**\n     * Computes the distance between two GPS locations. It takes Earth's radius\n     * into account.\n     * @param {Float} lat1 The latitude of the first GPS location in radians\n     * @param {Float} long1 The longitude of the first GPS location in radians\n     * @param {Float} lat2 The latitude of the second GPS location in radians\n     * @param {Float} long2 The longitude of the second GPS location in radians\n     * @returns {Float} The distance between two GPS locations.\n     */\n    calculateDistance: function(lat1, long1, lat2, long2){\n        var dLat = this.convertDegreesToRadians(lat2 - lat1);\n        var dLong = this.convertDegreesToRadians(long2 - long1);\n        var lat1_rads = this.convertDegreesToRadians(lat1);\n        var lat2_rads = this.convertDegreesToRadians(lat2);\n\n        var a = Math.pow(Math.sin(dLat / 2), 2) +\n                Math.pow(Math.sin(dLong / 2), 2) * \n                Math.cos(lat1_rads) * Math.cos(lat2_rads); \n        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n        return this.EARTH_RADIUS * c;\n    }\n};","import React from \"react\";\nimport \"./MapView.css\";\n\n// Imports for the map\nimport \"ol/ol.css\";\nimport {fromLonLat} from \"ol/proj.js\";\nimport {Map as OlMap, View as OlView} from \"ol\";\nimport {Tile as OlTileLayer, Vector as OlVectorLayer} from \"ol/layer.js\";\nimport OlOSM from \"ol/source/OSM.js\";\n\n// For drawing objects on the map\nimport OlVectorSource from \"ol/source/Vector.js\";\nimport OlGeoJSON from \"ol/format/GeoJSON.js\";\nimport OlStroke from \"ol/style/Stroke\";\nimport OlStyle from \"ol/style/Style\";\nimport OlCircleStyle from \"ol/style/Circle\";\nimport Stroke from \"ol/style/Stroke\";\n\n/**\n * A component which displays the map to the user\n * It uses OpenLayers as the map\n */\nclass MapView extends React.Component {\n\n    /**\n     * Constructs the component with initial properties\n     * @param {Object} props Initial properties\n     */\n    constructor(props){\n        super(props);\n        this.olMap = null;\n        this.olPathLayer = null;\n        this.olStopsLayer = null;\n    }\n\n    /**\n     * Creates and returns a new OpenLayers layer\n     * which will display the stops\n     * @returns {OlVectorLayer} Returns a Vector Layer that will display the stops.\n     */\n    createStopsLayer = () => {\n        var stopsStyle = new OlStyle({\n            image: new OlCircleStyle({\n                radius: 5,\n                fill: null,\n                stroke: new Stroke({\n                    color: \"red\",\n                    width: 1\n                })\n            })\n        });\n\n        var stopsStyleFunction = function(feature){\n            return stopsStyle;\n        };\n\n        var stopsLayer = new OlVectorLayer({\n            source: new OlVectorSource(),\n            style: stopsStyleFunction\n        });\n\n        return stopsLayer;\n    }\n\n    /**\n     * Updates the stops layer with new stops.\n     * It will clear the existing stops and render the new stops.\n     * \n     * If this.olStopsLayer is not set, it will not render the new stops.\n     * It will render the path on this.olStopsLayer.\n     * \n     * @param {Object} newStops The new stops\n     */\n    updateStopsLayer = (newStops) => {\n        let stopsGeoJsonObjects = newStops.map(item => {\n            return {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": fromLonLat([item.long, item.lat])\n                }\n            };\n        });\n\n        let geoJsonObject = {\n            \"type\": \"FeatureCollection\",\n            \"crs\": {\n                \"type\": \"name\",\n                \"properties\": {\n                    \"name\": \"EPSG:3857\"\n                }\n            },\n            \"features\": stopsGeoJsonObjects\n        };\n\n        if (this.olStopsLayer){\n            let source = this.olStopsLayer.getSource();\n\n            if (source){\n                source.clear();\n                source.addFeatures((new OlGeoJSON()).readFeatures(geoJsonObject));\n                source.refresh();\n            }\n        }\n    }\n\n    /**\n     * Creates and returns a new OpenLayers layer\n     * which will display the path of the trip\n     * @returns {OlVectorLayer} Returns a Vector Layer that will display the path of the trip.\n     */\n    createPathLayer = () => {\n        var pathStyle = new OlStyle({\n            stroke: new OlStroke({\n                color: \"green\",\n                width: 3\n            })\n        });\n\n        var pathStyleFunction = function(feature) {\n            return pathStyle;\n        };\n\n        var pathLayer = new OlVectorLayer({\n            source: new OlVectorSource(),\n            style: pathStyleFunction\n        });\n\n        return pathLayer;\n    }\n\n    /**\n     * Updates the path layer with a new path.\n     * It will clear the existing path and render the new path.\n     * \n     * If this.olPathLayer is not set, it will not render the new path.\n     * It will render the path on this.olPathLayer.\n     * \n     * @param {Object} newPath The new path\n     */\n    updatePathLayer = (newPath) => {\n        let pathCoordinates = newPath.map(item => {\n            return fromLonLat([item.long, item.lat]);\n        });\n\n        let geoJsonObject = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": pathCoordinates\n            }\n        };\n\n        if (this.olPathLayer){\n            let source = this.olPathLayer.getSource();\n\n            if (source){\n                source.clear();\n                source.addFeature((new OlGeoJSON()).readFeature(geoJsonObject));\n                source.refresh();\n            }\n        }\n    }\n\n    createLiveLocationLayer = () => {\n        var liveLocationStyle = new OlStyle({\n            image: new OlCircleStyle({\n                radius: 10,\n                fill: null,\n                stroke: new Stroke({\n                    color: \"blue\",\n                    width: 2\n                })\n            })\n        });\n        var liveLocationStyleFunction = function(feature) {\n            return liveLocationStyle;\n        };\n\n        var liveLocationLayer = new OlVectorLayer({\n            source: new OlVectorSource(),\n            style: liveLocationStyleFunction\n        });\n\n        return liveLocationLayer;\n    }\n\n    updateLiveLocationLayer = (newLatitude, newLongitude) => {\n        let geoJsonObject = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": fromLonLat([newLongitude, newLatitude])\n            }\n        };\n\n        if (this.olLiveLocationLayer){\n            let source = this.olLiveLocationLayer.getSource();\n\n            if (source){\n                source.clear();\n                source.addFeature((new OlGeoJSON()).readFeature(geoJsonObject));\n                source.refresh();\n            }\n        }\n    }\n\n    /**\n     * This method gets called whenever the HTML elements in this component is already \n     * in the DOM.\n     * \n     * It will create an initial view of the OpenLayers map as well as setting up\n     * the required layers.\n     */\n    componentDidMount(){        \n        // Create the view for the map\n        let initialLatitude = this.props.viewLocation.latitude;\n        let initialLongitude = this.props.viewLocation.longitude;\n        let mapZoom = this.props.zoom;\n        this.olView = new OlView({\n            center: fromLonLat([initialLongitude, initialLatitude]),\n            zoom: mapZoom\n        });\n        console.log(\"initialLatitude: \" + initialLatitude + \" | initialLongitude: \" + initialLongitude);\n\n        this.olPathLayer = this.createPathLayer();\n        this.olStopsLayer = this.createStopsLayer();\n        this.olLiveLocationLayer = this.createLiveLocationLayer();\n\n        // Initialize the map\n        this.olMap = new OlMap({\n            target: \"map\",\n            layers: [\n                new OlTileLayer({\n                    source: new OlOSM()\n                }),\n                this.olPathLayer,\n                this.olStopsLayer,\n                this.olLiveLocationLayer\n            ],\n            loadTilesWhileAnimating: true,\n            view: this.olView\n        });\n    }\n    \n    /**\n     * This method gets called whenever the component updates.\n     * This method will prevent the OpenLayers map from being\n     * deconstructed and re-instantiated and instead update the \n     * stops and the path displayed on the map.\n     * \n     * @param {Object} nextProps The new set of properties\n     * @param {Object} nextState The new set of states\n     */\n    shouldComponentUpdate(nextProps, nextState){\n        if (this.olMap !== null){\n            this.updateDimensions();\n\n            let newViewOptions = {};\n\n            if (this.props.viewLocation !== nextProps.viewLocation){\n                let initialLatitude = nextProps.viewLocation.latitude;\n                let initialLongitude = nextProps.viewLocation.longitude;\n\n                newViewOptions.center = fromLonLat([initialLongitude, initialLatitude]);\n                newViewOptions.duration = 2000;\n\n                console.log(\"initialLatitude: \" + initialLatitude + \" | initialLongitude: \" + initialLongitude);\n            }\n\n            if (this.props.zoom !== nextProps.zoom){\n                newViewOptions.zoom = nextProps.zoom;\n                newViewOptions.duration = 2000;\n            }\n\n            if (newViewOptions !== {}){\n                this.olView.animate(newViewOptions);\n            }\n\n            this.updatePathLayer(nextProps.path);\n            this.updateStopsLayer(nextProps.stops);\n\n            let curLatitude = nextProps.currentLocation.latitude;\n            let curLongitude = nextProps.currentLocation.longitude;\n            this.updateLiveLocationLayer(curLatitude, curLongitude);\n        }\n        return true;\n    }\n\n    /**\n     * This method is called whenever the component's dimensions changes.\n     * This method will re-compute the size for the OpenLayers map.\n     */\n    updateDimensions() {\n\n        // Reason for creating a timeout was described at:\n        // https://gis.stackexchange.com/questions/31409/openlayers-redrawing-map-after-container-resize\n        setTimeout(() => { \n            this.olMap.updateSize();\n        }, 200);\n    }\n\n    /**\n     * This method gets called whenever React wants to re-render the component.\n     */\n    render(){\n        return (<div id=\"map\" className=\"map\"></div>);\n    }\n}\n\nexport default MapView;","\n/**\n * Formats the number of seconds to its most appropriate unit of time.\n * @param {Integer} numSeconds The number of seconds\n */\nexport function getFormattedTime(numSeconds) {\n    let numHrsRemaining = Math.trunc(numSeconds / 3600);\n    numSeconds = numSeconds % 3600;\n    \n    let numMinRemaining = Math.trunc(numSeconds / 60);\n    numSeconds = numSeconds % 60;\n\n    let remainingTimeValue = \"\";\n    let remainingTimeUnit = \"hours\";\n    if (numHrsRemaining >= 1){\n        if (numHrsRemaining === 1 && numMinRemaining === 0){\n            remainingTimeValue = \"1\";\n            remainingTimeUnit = \"hour\";\n        }\n        else{\n            remainingTimeValue = numHrsRemaining + \":\" + Math.trunc(numMinRemaining).toString().padStart(2, \"0\");\n            remainingTimeUnit = \"hours\";\n        }\n    }\n    else if (numMinRemaining >= 1){\n        if (numMinRemaining === 1 && numSeconds === 0){\n            remainingTimeValue = \"1\";\n            remainingTimeUnit = \"minute\";\n        }\n        else{\n            remainingTimeValue = numMinRemaining + \":\" + Math.trunc(numSeconds).toString().padStart(2, \"0\");\n            remainingTimeUnit = \"minutes\";\n        }\n    }\n    else {\n        if (numSeconds === 1){\n            remainingTimeValue = \"1\";\n            remainingTimeUnit = \"second\";\n        }\n        else{\n            remainingTimeValue = numSeconds.toString();\n            remainingTimeUnit = \"seconds\";\n        }\n    }\n\n    return {\n        value: remainingTimeValue,\n        unit: remainingTimeUnit\n    };\n}\n\n/**\n * Returns the number of seconds from midnight a date object \n * @param {Date} dateObject A date object\n */\nexport function getTimeInSeconds(dateObject){\n    let numHrsFromMidnight = dateObject.getHours();\n    let numMinFromHr = dateObject.getMinutes();\n    let numSecFromMin = dateObject.getSeconds();\n    return numSecFromMin + (60 * numMinFromHr) + (3600 * numHrsFromMidnight);\n}","export function getCurrentTime(){\n    return new Date();\n}\n\n","import React from \"react\";\n\nimport { getFormattedTime, getTimeInSeconds } from \"../../services/TimeFormatter\";\nimport \"./RouteDetailsView.css\";\nimport {getCurrentTime} from \"../../services/TimeService\";\n\nclass RouteDetailsView extends React.Component {\n\n    state = {\n        stops: []\n    }\n\n    componentDidMount() {\n        // Set \"prevTime\" to -1 so that it will always pass the if statement on the first run.\n        let prevTime = -1;  \n\n        this.timer = setInterval(() => {\n\n            var numSecAfterMidnight = getTimeInSeconds(getCurrentTime());\n\n            // Update only if the time has changed.\n            if (numSecAfterMidnight > prevTime){\n\n                // Get the stops that did not pass by and calculate its remaining time.\n                let updatedStops = this.props.stops\n                    .filter(item => item.time > numSecAfterMidnight)\n                    .map(item => {\n                        return {\n                            ...item,\n                            remainingTimeInSeconds: item.time - numSecAfterMidnight\n                        }\n                    });\n\n                // Set the current time in seconds to the state\n                this.setState((prevState, props) => {\n                    return {\n                        ...prevState, \n                        stops: updatedStops\n                    };\n                });  \n\n                prevTime = numSecAfterMidnight;\n            }\n        });\n    }\n\n    componentWillUnmount(){\n        clearInterval(this.timer);\n    }\n\n    render(){\n        let stopContainers = this.state.stops.map(item => {\n            let formattedRemainingTime = getFormattedTime(item.remainingTimeInSeconds);\n\n            // Get the class for whether it is selected or not\n            let alarmClassName = \"stop-interaction-button\";\n            if (this.props.alarms[item.ID] !== undefined){\n                alarmClassName += \" stop-interaction-button-selected\";\n            }\n\n            return (\n                <div key={item.ID} className=\"stop-container\">\n                    <div className=\"stop-info-container\">\n                        <div className=\"stop-name\">{item.name}</div>\n\n                        <div className=\"remaining-time\">\n                            <div className=\"remaining-time-value\">{formattedRemainingTime.value}</div>\n                            <div className=\"remaining-time-unit\">{formattedRemainingTime.unit}</div>\n                        </div>\n                    </div>\n                    <div className=\"stop-interactions-container\">\n                        <div className=\"stop-interactions\">\n                            <div className={alarmClassName}\n                                 onClick={e => {\n                                     if (this.props.alarms[item.ID] === undefined){\n                                        this.props.addNewAlarmHandler(item.ID);\n                                     }\n                                     else{\n                                        this.props.removeAlarmHandler(item.ID);\n                                     }\n                                 }}>\n                                Notify me\n                            </div>\t\t\t\t\n                        </div>\n                    </div>\n                </div>\n            );\n        });\n        return (\n            <div>\n                <div className=\"trip-header-details-container\">\n                    <div className=\"trip-header-details\">\n                        <h3 className=\"short-name\">{this.props.tripShortName}</h3>\n                        <p className=\"long-name\">{this.props.tripLongName}</p>\n                    </div>\n                </div>\n                <div className=\"stop-containers-list\">\n                    {stopContainers}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default RouteDetailsView;","import React from \"react\";\nimport \"./RouteChooserPopup.css\";\nimport \"./../popup/Popup.css\"\n\nimport {getCurrentTime} from \"../../services/TimeService\";\n\nclass NearbyTripsChooserPopup extends React.Component {\n\n    handleSubmit = (event) => {\n        event.preventDefault();\n        console.log(\"Hi there!\");\n        console.log(event.target.route.value);\n\n        let selectedTripID = event.target.route.value;\n        console.log(\"I am here!\");\n        if (selectedTripID === \"\"){\n            // Show error message\n        }\n        else{\n            this.props.onSelectRoute(selectedTripID);\n        }\n    }\n\n    render() {\n        let areThereRoutes = this.props.routes.length > 0;\n        let rows = this.props.routes.map((item, index) => {\n            let shortName = item.shortName;\n            let longName = item.longName;\n            let headsign = item.headsign;\n\n            let display = \"\";\n            if (shortName){\n                display += shortName + \" \";\n            }\n            if (headsign){\n                display += headsign + \" \";\n            }\n            if (longName){\n                display += \"(\" + longName + \")\";\n            }\n            display.trim();\n\n            return {\n                ...item,\n                display: display\n            };\n        }).sort((tripA, tripB) => {\n            return tripA.display < tripB.display;\n        }).filter(trip => {\n            return trip.startTime <= getCurrentTime() <= trip.endTime;\n        }).map(item => {\n            let tripID = item.tripID;\n            let display = item.display;\n            \n            return (\n                <div key={tripID}>\n                    <input type=\"radio\" name=\"route\" value={tripID}/>\n                    <div className=\"tripInfo\">{display}</div>\n                </div>\n            );\n\n        });\n\n        return (\n            <div className=\"popup-background\">\n                <div className=\"popup-container\">\n                    <div className=\"popup\">\n                        <div className=\"popup-header\">{\n                            areThereRoutes\n                                ? <div>\n                                    <h3>Which bus / train are you on?</h3>\n                                    <p>\n                                        There are multiple bus / train routes near your area. \n                                        Please select which route you are currently on.\n                                    </p>\n                                  </div>\n                                : <div>\n                                    <h3>There are no busses / trains near you!</h3>\n                                    <p>Are you on a bus / train? If not, this explains why we cannot find your bus / train!</p>\n                                  </div>\n                        }</div>\n                        <form onSubmit={this.handleSubmit}>\n                            <div className=\"popup-contents\">{\n                                areThereRoutes\n                                    ? rows\n                                    : <p>Please wait while we try to determine the busses / trains around you.</p>\n                            }</div>\n                            <div className=\"popup-actions-container\">{\n                                areThereRoutes\n                                    ?  <button className=\"popup-action-button\" type=\"submit\">\n                                        OK\n                                      </button>\n                                    : null\n                            }</div>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default NearbyTripsChooserPopup;","import React from \"react\";\nimport \"./LoadingPopup.css\";\nimport \"./../popup/Popup.css\"\n\nclass LoadingPopup extends React.Component {\n\n    render() {\n        return (\n            <div className=\"popup-background\">\n                <div className=\"popup-container\">\n                    <div className=\"popup\">\n                        <div className=\"popup-header\"></div>\n                        <div className=\"popup-contents\">\n                            <div className=\"loader\">\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                                <div></div>\n                            </div>\n                            <h2 className=\"loading-sign\">Loading...</h2>\n                        </div>\n                        <div className=\"popup-actions-container\">\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default LoadingPopup;","import Axios from \"axios\";\nAxios.defaults.timeout = 180000;\n\nconst TRIPS_LOCATOR_URL = \"https://on-transit-app-api-gateway.herokuapp.com/api/v1/trips\";\nconst TRIP_DETAILS_URL = \"https://on-transit-app-api-gateway.herokuapp.com/api/v1/trips\";\nconst VEHICLES_LOCATOR_URL = \"https://on-transit-app-api-gateway.herokuapp.com/api/v1/vehicles\";\n\nclass OnTransitService {\n\n    async getNearbyTrips(latitude, longitude, time, radius){\n        try{\n            let urlParams = {\n                lat: latitude,\n                long: longitude,\n                time: time,\n                radius: radius\n            };\n            let options = {\n                params: urlParams\n            }\n            let rawData = await Axios.get(TRIPS_LOCATOR_URL, options);\n            console.log(rawData);\n            return rawData.data.data;\n        }\n        catch(error){\n            throw error;\n        }\n    }\n\n    async getTripDetails(tripID){\n        try{\n            let url = TRIP_DETAILS_URL + \"/\" + tripID;\n            let rawData = await Axios.get(url);\n            return rawData.data.data;\n        }\n        catch(error){\n            throw error;\n        }\n    }\n\n    async getNearbyVehicles(latitude, longitude, radius){\n        try{\n            let urlParams = {\n                lat: latitude,\n                long: longitude,\n                radius: radius\n            };\n            let options = {\n                params: urlParams\n            };\n            let rawData = await Axios.get(VEHICLES_LOCATOR_URL, options);\n            return rawData.data.data;\n        }\n        catch(error){\n            throw error;\n        }\n    }\n}\n\nexport default OnTransitService;","const GIS = require(\"../utils/Gis\");\n\n/**\n * Returns two indexes, i and i + 1 where stops[i].time <= time && time <= stops[i + 1].time.\n * Pre-condition: stops must contain the following structure:\n *  [{\n *      lat: <latitude of stop in radians>\n *      long: <longitude of stop in radians>\n *      time: <expected time of bus / train to arrive at in seconds after midnight>\n *   }, \n *   ...\n *  ]\n * @param {Object[]} stops A list of stops sorted by time in ascending order\n * @param {Integer} time The time in seconds after midnight\n */\nfunction findBoundaryBetweenTwoStops(stops, time){\n    let left = 0;\n    let right = stops.length;\n\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        let nextMid = mid + 1;\n\n        let stopA = stops[mid];\n        let stopB = stops[nextMid];\n\n        if (stopA.time <= time && time <= stopB.time){\n            return [mid, nextMid];\n        }\n        else if (time < stopA.time){\n            right = mid - 1;\n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    throw new Error(\"Cannot find boundary between two stops!\");\n}\n\n/**\n * Computes the total distance of a path segment from path[startIndex] \n * to path[endIndex] not including path[endIndex]\n * @param {Object[]} path A list of path locations in order\n * @param {*} startIndex The index to the start of a path segment\n * @param {*} endIndex The index to the end of a path segment\n * @returns {Float} The total distance of a path segment\n */\nfunction computeTotalDistanceBetweenPath(path, startIndex, endIndex){\n    let totalDistance = 0;\n    for (let i = startIndex; i < endIndex; i++){\n        let curPathLocation = path[i];\n        let nextPathLocation = path[i + 1];\n\n        let lat1 = curPathLocation.lat;\n        let long1 = curPathLocation.long;\n        let lat2 = nextPathLocation.lat;\n        let long2 = nextPathLocation.long;\n        let curDistance = GIS.calculateDistance(lat1, long1, lat2, long2);\n\n        totalDistance += curDistance;\n    }\n    return totalDistance;\n}\n\n/**\n * Predicts the location in a path segment given the amount already travelled in the path segment.\n * @param {Object[]} path A set of coordinates in sorted form which outlines the path.\n * @param {Integer} startPathIndex The index to the start of a path segment in path[]\n * @param {Integer} endPathIndex The index to the end of a path segment in path[]\n * @param {Float} ratio The current amount of distance already travelled from the start \n *      of the path to the end of the path segment.\n */\nfunction predictLocation(path, startPathIndex, endPathIndex, ratio){\n    let totalDistanceOfPath = computeTotalDistanceBetweenPath(path, startPathIndex, endPathIndex);\n    let distanceToTravel = totalDistanceOfPath * ratio;\n\n    /**\n     * Get the path index \"closestPathIndex\" s.t. the predicted location is between \n     * path[closestPathIndex] and path[closestPathIndex + 1] inclusive.\n     */\n    let closestPathIndex = startPathIndex;\n    while(closestPathIndex < endPathIndex){\n        let curPathLocation = path[closestPathIndex];\n        let nextPathLocation = path[closestPathIndex + 1];\n\n        let lat1 = curPathLocation.lat;\n        let long1 = curPathLocation.long;\n        let lat2 = nextPathLocation.lat;\n        let long2 = nextPathLocation.long;\n        let curDistance = GIS.calculateDistance(lat1, long1, lat2, long2);\n\n        if (distanceToTravel - curDistance < 0){\n            break;\n        }\n        distanceToTravel -= curDistance;\n        closestPathIndex ++;\n    }\n\n    // Get the predicted location between path[closestPathIndex] and path[closestPathIndex + 1]\n    if (closestPathIndex === endPathIndex){\n        return {\n            lat: path[closestPathIndex].lat,\n            long: path[closestPathIndex].long\n        };\n    }\n    else{\n        let closestPath = path[closestPathIndex];\n        let nextPath = path[closestPathIndex + 1];\n\n        let bearing = GIS.computeBearings(nextPath.lat, nextPath.long, closestPath.lat, closestPath.long);\n        return GIS.calculateDestinationPoint(closestPath.lat, closestPath.long, bearing, distanceToTravel);\n    }\n}\n\nfunction getNearestPathLocation(location, path){\n    let curIndex = 0;\n    let minIndex = 0;\n    let maxIndex = 0;\n    let minDistance = Infinity;\n    while (curIndex < path.length){\n        let curPathLocation = path[curIndex];\n        let curDistance = GIS.calculateDistance(location.lat, location.long, curPathLocation.lat, curPathLocation.long);\n\n        if (curDistance < minDistance){\n            minDistance = curDistance;\n            minIndex = curIndex;\n            maxIndex = curIndex;\n        }\n        else if (curDistance == minDistance){\n            maxIndex = curIndex;\n        }\n\n        curIndex ++;\n    }\n    return {\n        minIndex: minIndex,\n        maxIndex: maxIndex\n    };\n}\n\nexport function GetLocationOnPath(stops, path, time){\n    let adjacentStopIndexes = findBoundaryBetweenTwoStops(stops, time);\n    let leftStop = stops[adjacentStopIndexes[0]];\n    let rightStop = stops[adjacentStopIndexes[1]];\n    let startPathIndex = getNearestPathLocation(leftStop, path).minIndex;\n    let endPathIndex = getNearestPathLocation(rightStop, path).maxIndex;\n\n    let ratio = (time - leftStop.time) / (rightStop.time - leftStop.time);\n    let predictedLocation = predictLocation(path, startPathIndex, endPathIndex, ratio);\n\n    return predictedLocation;\n}","import React from \"react\";\nimport \"./../popup/Popup.css\";\n\nclass EndOfRoutePopup extends React.Component {\n    state = {\n        countdownValue: 5\n    }\n    \n    componentDidMount() {\n        this.countdownInterval = setInterval(() => {\n            if (this.state.countdownValue <= 0){\n                this.props.restartApp();\n            }\n\n            else{\n                this.setState((prevState, props) => {\n                    return {\n                        countdownValue: prevState.countdownValue - 1\n                    };\n                });\n            }\n        }, 1000);\n    }\n\n    componentWillUnmount(){\n        if (this.countdownInterval){\n            clearInterval(this.countdownInterval);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"popup-background\">\n                <div className=\"popup-container\">\n                    <div className=\"popup\">\n                        <div className=\"popup-header\">\n                            <h3>Which bus / train are you on?</h3>\n                        </div>\n                        <form onSubmit={this.handleSubmit}>\n                            <div className=\"popup-contents\">\n                                <p>The bus or train has completed its trip! You will need to select a different trip.</p>\n\t\t\t\t\t            <p>You will be redirected in <span>{this.state.countdownValue} seconds</span>.</p>\n                            </div>\n                            <div className=\"popup-actions-container\">\n                            </div>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default EndOfRoutePopup;","import React from 'react';\nimport { ToastContainer, toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\n\nimport \"./App.css\";\nimport Map from \"../map-view/MapView\";\nimport RouteDetailsView from '../route-details-view/RouteDetailsView.js';\nimport RouteChooserPopup from \"../route-chooser-popup/RouteChooserPopup\";\nimport LoadingPopup from \"../loading-popup/LoadingPopup\";\nimport { getFormattedTime, getTimeInSeconds } from \"../../services/TimeFormatter\";\n\nimport {getCurrentTime} from \"../../services/TimeService\";\n\nimport MockedOnTransitService from '../../services/OnTransitService.js';\n\nimport {GetLocationOnPath} from \"../../services/LocationTracker\";\nimport EndOfRoutePopup from '../end-of-route-popup/EndOfRoutePopup';\n\nclass App extends React.Component {\n    state = {\n        displayLoadingSign: true,\n        displayRouteChoices: false,\n        displayRouteDetails: false,\n        displayEndOfRouteMessage: false,\n        mapZoom: 3,\n        curLocation: {\n            latitude: 43.554028,\n            longitude: -79.722099\n        },\n        initLocation: {\n            latitude: 0,\n            longitude: 0\n        },\n        possibleRoutes: [],\n        tripDetailsID: null,\n        tripDetails: {\n            shortName: null,\n            longName: null,\n            path: [],\n            stops: []\n        },\n        alarms: {}\n    }\n\n    async componentDidMount(){\n        this.onTransitService = new MockedOnTransitService();\t\n        \n        \n        if (!(\"Notification\" in window)){\n            alert(\"Notifications are not supported in this browser!\");\n        }\n\n        Notification.requestPermission();\n\n        this.startGeolocationWatch();\n        this.startAlarmWatch();\n    }\n\n    restartApp = () => {\n        this.componentWillUnmount();\n        this.setState((prevState, props) => {\n            return {\n                displayRouteChoices: false,\n                displayRouteDetails: false,\n                displayEndOfRouteMessage: false,\n                mapZoom: 3,\n                curLocation: {\n                    latitude: 43.554028,\n                    longitude: -79.722099\n                },\n                initLocation: {\n                    latitude: 0,\n                    longitude: 0\n                },\n                possibleRoutes: [],\n                tripDetailsID: null,\n                tripDetails: {\n                    shortName: null,\n                    longName: null,\n                    path: [],\n                    stops: []\n                },\n                alarms: {}\n            };\n        });\n        this.componentDidMount();\n    }\n\n    startGeolocationWatch = () => {\n        // Initialize and watch the location\n        let geolocationOptions = {\n            enableHighAccuracy: true,\n            timeout: Infinity,\n            maximumAge: 0\n        };\n\n        if (navigator.geolocation){\n            this.geolocationWatch = navigator.geolocation.watchPosition(\n                this.onLocationChangedSuccess, this.onLocationChangedError, geolocationOptions);\n        }\n    };\n\n    startPredictedLocationWatch = () => {\n        if (this.state.tripDetails.stops.length > 1){\n            this.liveLocationWatch = setInterval(() => {\n                let stops = this.state.tripDetails.stops;\n                let path = this.state.tripDetails.path;\n                let currentTimeInSeconds = getTimeInSeconds(getCurrentTime());\n                let lastStop = stops[stops.length - 1];\n\n                if (currentTimeInSeconds >= lastStop.time){\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            displayEndOfRouteMessage: true,\n                            displayRouteDetails: false\n                        };\n                    });\n                }\n                else{\n                    let predictedLocation = GetLocationOnPath(stops, path, currentTimeInSeconds);\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            curLocation: {\n                                latitude: predictedLocation.lat,\n                                longitude: predictedLocation.long\n                            }\n                        };\n                    });\n                }\n            });\n        }\n    }\n\n    startAlarmWatch = () => {\n        this.alarmInterval = setInterval(() => {\n            var curTimeInSeconds = getTimeInSeconds(getCurrentTime());\n\n            Object.keys(this.state.alarms).forEach(stopID => {\n                // Get the stop detail for that stopID\n                let stopDetails = this.state.tripDetails.stops.find(stop => {\n                    return stop.ID == stopID;\n                });\n\n                if (stopDetails !== undefined){\n                    let alarmDetails = this.state.alarms[stopID];\n                    let remainingTimeLeft = stopDetails.time - curTimeInSeconds;\n\n                    if (remainingTimeLeft < alarmDetails.minRemainingTimeLeft && !alarmDetails.isDispatched){\n                        console.log(\"RING RING RING!!!\");\n                        this.dispatchAlarm(stopDetails);\n                        this.removeAlarm(stopID);\n                    }\n                }\n                else{\n                    throw new Error(\"Inconsistency with stop ID \" + stopID + \" and trip details!\");\n                }\n            });\n        });\n    }\n\n    stopAlarmWatch = () => {\n        if (this.alarmInterval){\n            clearInterval(this.alarmInterval);\n        }\n    }\n\n    stopLiveLocationWatch = () => {\n        if (this.liveLocationWatch){\n            clearInterval(this.liveLocationWatch);\n        }\n    }\n\n    stopGeolocationWatch = () => {\n        navigator.geolocation.clearWatch(this.geolocationWatch);\n    }\n\n    componentWillUnmount(){\n        this.stopAlarmWatch();\n        this.stopLiveLocationWatch();\n        this.stopGeolocationWatch();       \n    }\n\n    onLocationChangedSuccess = (position) => {\n        let latitude = position.coords.latitude;\n        let longitude = position.coords.longitude;\n        let radius = position.coords.accuracy;\n        let time = new Date().toLocaleTimeString();\n\n        console.log(this.state);\n\n        if (this.state.possibleRoutes === null || this.state.possibleRoutes.length == 0){\n            console.log(\"heee\");\n\n            // Get the nearby trips and vehicles\n            let nearbyTripsPromise = this.onTransitService.getNearbyTrips(latitude, longitude, time, radius);\n            let nearbyVehiclesPromise = this.onTransitService.getNearbyVehicles(latitude, longitude, radius);\n\n            this.setState((prevState, props) => {\n                return {\n                    ...prevState,\n                    displayLoadingSign: true\n                }\n            });\n            \n            Promise.all([nearbyTripsPromise, nearbyVehiclesPromise])\n                .then(values => {  \n                    \n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            displayLoadingSign: false\n                        }\n                    });\n                    \n                    if (this.state.possibleRoutes !== null && this.state.possibleRoutes.length > 0){\n                        return;\n                    }\n\n                    console.log(Object.keys(values[0].tripIDs));\n                    \n                    let nearbyTrips = Object.keys(values[0].tripIDs).map(key => {\n                        let tripID = key;\n                        let tripDetails = values[0].tripIDs[tripID];\n                        return {\n                            ...tripDetails, \n                            tripID: tripID\n                        };\n                    });\n\n                    console.log(nearbyTrips);\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            displayRouteChoices: true,\n                            possibleRoutes: nearbyTrips,\n                            curLocation: {\n                                latitude: latitude,\n                                longitude: longitude\n                            }\n                        };\n                    });                   \n                })\n                .catch(errors => {\n                    console.log(errors);\n                });\n        }\n    }\n\n    onLocationChangedError = (error) => {\n        console.log(\"ERROR!\");\n        console.log(error);\n    }\n\n    selectRoute = (tripID) => {\n        console.log(\"Selected Trip ID: \" + tripID);\n        if (this.state.tripDetailsID !== tripID){\n            this.setState((prevState, props) => {\n                return {\n                    ...prevState,\n                    displayLoadingSign: true\n                }\n            });\n\n            this.onTransitService.getTripDetails(tripID)\n                .then(results => {\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            displayLoadingSign: false\n                        }\n                    });\n\n                    // Set the ID of results to their index\n                    results.stops = results.stops.map((item, index) => {\n                        return {\n                            ...item,\n                            ID: index\n                        };\n                    });\n\n                    // Get the midpoint between all the path locations\n                    let sumOfAllPathLatitudes = results.path.reduce((curSum, item) => curSum + item.lat, 0);\n                    let sumOfAllPathLongitudes = results.path.reduce((curSum, item) => curSum + item.long, 0);\n                    let midPathLatitude = sumOfAllPathLatitudes / results.path.length;\n                    let midPathLongitude = sumOfAllPathLongitudes / results.path.length;\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            initLocation: {\n                                latitude: midPathLatitude,\n                                longitude: midPathLongitude\n                            },\n                            tripDetailsID: tripID,\n                            displayRouteDetails: true,\n                            displayRouteChoices: false,\n                            tripDetails: results,\n                            mapZoom: 13,\n                            alarms: {}\n                        };\n                    }, () => {\n                        this.startPredictedLocationWatch();\n                    });\n                })\n                .catch(error => {\n                    console.log(error);\n                });\n        }\n    }\n\n    addNewAlarm = (stopID) => {\n\n        if (this.state.tripDetails.stops[stopID.toString()]){\n            this.setState((prevState, props) => {\n                let newAlarms = prevState.alarms;\n                newAlarms[stopID] = { \n                    minRemainingTimeLeft: 300, //<- 300 seconds is 5 minutes\n                    isDispatched: false\n                }; \n\n                // Display a toast message to the user that an alarm is added.\n                let stopDetails = this.state.tripDetails.stops[stopID.toString()];\n                let toastMessage = \"You will be notified 5 minutes before reaching \" + stopDetails.name;\n                toast(toastMessage, {\n                    position: toast.POSITION.BOTTOM_CENTER\n                });\n                console.log(toastMessage);\n\n                return {\n                    ...prevState,\n                    alarms: newAlarms\n                };\n            });\t\t\t\n        }\n        else{\n            throw new Error(\"Inconsistencies with stopID \" + stopID + \" and this.state.tripDetails.stops\");\n        }\n    }\n\n    removeAlarm = (stopID) => {\n\n        this.setState((prevState, props) => {\n            delete prevState.alarms[stopID.toString()];\n\n            // Display a toast message to the user that the notification is removed\n            let stopDetails = this.state.tripDetails.stops[stopID.toString()];\n            let toastMessage = \"Removed notification for stop \" + stopDetails.name;\n            toast(toastMessage, {\n                position: toast.POSITION.BOTTOM_CENTER\n            });\n\n            console.log(toastMessage);\n\n            return prevState;\n        });\n        \n        console.log(\"Removed alarm \" + stopID);\n    }\n\n    dispatchNotification = (message, timeBeforeClosingNotification) => {\n        // Notify the user via Web Notifications\n        Notification.requestPermission()\n            .then((permission) => {\n                if (permission !== \"granted\"){\n                    throw new Error(\"No access!\");\n                }\n            })\n            .then(() => {\n                console.log(\"We have access here!\");\n                let notification = new Notification(message);\n\n                // Close the notification after 10 seconds\n                setTimeout(() => {\n                    notification.close();\n                }, timeBeforeClosingNotification);\n            })\n            .catch(error => {\n                console.log(\"We have no access here!\");\n            });\n    }\n\n    dispatchAlarm = (stopDetails) => {\n        // let curTimeInSeconds = getTimeInSeconds(new Date());\n        let curTimeInSeconds = getTimeInSeconds(getCurrentTime());\n\n        let numSecondsRemaining = stopDetails.time - curTimeInSeconds;\n        let formattedTimeRemaining = getFormattedTime(numSecondsRemaining);\n        let stopID = stopDetails.ID;\n\n        let notificationContent = \"You are \" +  \n            formattedTimeRemaining.value + \" \" + \n            formattedTimeRemaining.unit + \" away from \" + \n            stopDetails.name;\n\n        this.dispatchNotification(notificationContent, 10000);\n\n        this.setState((prevState, props) => {\n            let newAlarms = prevState.alarms;\n            newAlarms[stopID.toString()].isDispatched = true;\n\n            return {\n                ...prevState,\n                alarms: newAlarms\n            };\n        });\n    }\n \n    render() {\n        return (\n            <div className=\"app-container\">\n                {\n                    this.state.displayRouteDetails\n                        ? <div className=\"left-panel\">\n                            <RouteDetailsView\n                                tripShortName={this.state.tripDetails.shortName}\n                                tripLongName={this.state.tripDetails.longName}\n                                stops={this.state.tripDetails.stops}\n                                alarms={this.state.alarms}\n                                addNewAlarmHandler={this.addNewAlarm}\n                                removeAlarmHandler={this.removeAlarm}/>\n                          </div>\n                        : null\n                }\n                <div className=\"right-panel\">\n                    <Map viewLocation={this.state.initLocation}\n                         zoom={this.state.mapZoom}\n                         currentLocation={this.state.curLocation}\n                         path={this.state.tripDetails.path}\n                         stops={this.state.tripDetails.stops} />\n                </div>\t\t\t\t\n                {\n                    (this.state.displayRouteChoices && !this.state.displayLoadingSign)\n                        ? <RouteChooserPopup \n                            routes={this.state.possibleRoutes}\n                            onSelectRoute={this.selectRoute}/> \n                        : null \n                }\t\n                {\n                    (this.state.displayEndOfRouteMessage && !this.state.displayLoadingSign)\n                        ? <EndOfRoutePopup restartApp={this.restartApp}/>\n                        : null\n                }\n                {\n                    this.state.displayLoadingSign\n                        ? <LoadingPopup />\n                        : null\n                }\n                <ToastContainer />\t\t\n            </div>\n        );\n    }\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app/App';\n\nReactDOM.render(\n    <App/>, \n    document.getElementById('root')\n);"],"sourceRoot":""}