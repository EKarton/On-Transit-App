{"version":3,"sources":["utils/Gis.js","services/LocationTracker.js","components/map-view/MapView.js","services/TimeFormatter.js","services/TimeService.js","components/route-details-view/RouteDetailsView.js","components/route-chooser-popup/RouteChooserPopup.js","services/OnTransitService.js","components/end-of-route-popup/end-of-route-popup.js","components/app/App.js","index.js"],"names":["module","exports","EARTH_RADIUS","convertDegreesToRadians","degrees","Math","PI","convertRadiansToDegrees","radians","computeBearings","lat1","long1","lat2","long2","y","sin","cos","x","bearingInRadans","atan2","this","calculateDestinationPoint","lat","long","bearing","distance","latInRads","longInRads","angularDistance","bearingInRads","lat2InRads","asin","lat2InDegrees","long2InRads","calculateDistance","dLat","dLong","lat1_rads","lat2_rads","a","pow","c","sqrt","GIS","require","predictLocation","path","startPathIndex","endPathIndex","ratio","distanceToTravel","startIndex","endIndex","totalDistance","i","curPathLocation","nextPathLocation","computeTotalDistanceBetweenPath","closestPathIndex","curDistance","closestPath","nextPath","getNearestPathLocation","location","curIndex","minIndex","maxIndex","minDistance","Infinity","length","GetLocationOnPath","stops","time","adjacentStopIndexes","left","right","mid","floor","nextMid","stopA","stopB","Error","findBoundaryBetweenTwoStops","leftStop","rightStop","MapView","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","createStopsLayer","stopsStyle","OlStyle","image","OlCircleStyle","radius","fill","stroke","Stroke","color","width","OlVectorLayer","source","OlVectorSource","style","feature","updateStopsLayer","newStops","geoJsonObject","type","crs","properties","name","features","map","item","geometry","coordinates","fromLonLat","olStopsLayer","getSource","clear","addFeatures","OlGeoJSON","readFeatures","refresh","createPathLayer","pathStyle","OlStroke","updatePathLayer","newPath","olPathLayer","addFeature","readFeature","createLiveLocationLayer","liveLocationStyle","updateLiveLocationLayer","newLatitude","newLongitude","olLiveLocationLayer","olMap","initialLatitude","viewLocation","latitude","initialLongitude","longitude","mapZoom","zoom","olView","OlView","center","console","log","OlMap","target","layers","OlTileLayer","OlOSM","loadTilesWhileAnimating","view","nextProps","nextState","updateDimensions","newViewOptions","duration","animate","curLatitude","currentLocation","curLongitude","_this2","setTimeout","updateSize","react_default","createElement","id","className","React","Component","getFormattedTime","numSeconds","numHrsRemaining","trunc","numMinRemaining","remainingTimeValue","remainingTimeUnit","toString","padStart","value","unit","getTimeInSeconds","dateObject","numHrsFromMidnight","getHours","numMinFromHr","getMinutes","getSeconds","getCurrentTime","Date","RouteDetailsView","state","prevTime","timer","setInterval","numSecAfterMidnight","updatedStops","filter","objectSpread","remainingTimeInSeconds","setState","prevState","clearInterval","_this3","stopContainers","formattedRemainingTime","alarmClassName","undefined","alarms","ID","key","onClick","e","addNewAlarmHandler","removeAlarmHandler","tripShortName","tripLongName","NearbyTripsChooserPopup","handleSubmit","event","preventDefault","route","selectedTripID","onSelectRoute","areThereRoutes","routes","rows","index","shortName","longName","headsign","display","trim","sort","tripA","tripB","trip","startTime","endTime","tripID","onSubmit","Axios","defaults","timeout","OnTransitService","options","params","get","rawData","data","url","TRIP_DETAILS_URL","EndOfRoutePopup","countdownValue","countdownInterval","restartApp","App","displayRouteChoices","displayRouteDetails","displayEndOfRouteMessage","curLocation","initLocation","possibleRoutes","tripDetailsID","tripDetails","componentWillUnmount","componentDidMount","startGeolocationWatch","geolocationOptions","enableHighAccuracy","maximumAge","navigator","geolocation","geolocationWatch","watchPosition","onLocationChangedSuccess","onLocationChangedError","startPredictedLocationWatch","liveLocationWatch","currentTimeInSeconds","predictedLocation","startAlarmWatch","alarmInterval","curTimeInSeconds","keys","forEach","stopID","stopDetails","find","stop","alarmDetails","minRemainingTimeLeft","isDispatched","dispatchAlarm","removeAlarm","stopAlarmWatch","stopLiveLocationWatch","stopGeolocationWatch","clearWatch","position","coords","accuracy","toLocaleTimeString","nearbyTripsPromise","onTransitService","getNearbyTrips","nearbyVehiclesPromise","getNearbyVehicles","Promise","all","then","values","tripIDs","nearbyTrips","catch","errors","error","selectRoute","getTripDetails","results","sumOfAllPathLatitudes","reduce","curSum","sumOfAllPathLongitudes","midPathLatitude","midPathLongitude","addNewAlarm","newAlarms","toastMessage","toast","POSITION","BOTTOM_CENTER","dispatchNotification","message","timeBeforeClosingNotification","Notification","requestPermission","permission","notification","close","formattedTimeRemaining","notificationContent","MockedOnTransitService","window","alert","components_route_details_view_RouteDetailsView","components_map_view_MapView","route_chooser_popup_RouteChooserPopup","end_of_route_popup_end_of_route_popup","lib","ReactDOM","render","components_app_App","document","getElementById"],"mappings":"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","file":"static/js/main.18ca3a6b.chunk.js","sourcesContent":["/**\n * A library used to perform GPS location calculations\n */\nmodule.exports = {\n    EARTH_RADIUS: 6371000, // in meters\n\n    /**\n     * Converts an angle from degrees to radians\n     * @param {Float} degrees Angle in degrees\n     * @returns {Float} Angle in radians\n     */\n    convertDegreesToRadians: function(degrees){\n        return degrees * Math.PI / 180;\n    },\n\n    /**\n     * Converts an angle from radians to degrees\n     * @param {Float} radians Angle in radians\n     * @returns {Float} Angle in degrees\n     */\n    convertRadiansToDegrees: function(radians){\n        return (radians * 180) / Math.PI;\n    },\n\n    /**\n     * Computes the bearing from the first GPS location to the last GPS location in degrees\n     * @param {Float} lat1 The latitude of the first GPS location in degrees\n     * @param {Float} long1 The longitude of the first GPS location in degrees\n     * @param {Float} lat2 The latitude of the last GPS location in degrees\n     * @param {Float} long2 The longitude of the last GPS location in degrees\n     * @returns {Float} The bearing from the first GPS location to the last GPS location.\n     */\n    computeBearings: function(lat1, long1, lat2, long2){\n        let y = Math.sin(long2 - long1) * Math.cos(lat2);\n        let x = (Math.cos(lat1) * Math.sin(lat2)) - \n                (Math.sin(lat1) * Math.cos(lat2) * Math.cos(long2 - long1));\n        let bearingInRadans = Math.atan2(y, x);\n        let bearingInDegrees = this.convertRadiansToDegrees(bearingInRadans);\n        return (bearingInDegrees + 180) % 360;\n    },\n\n    /**\n     * Calculates the approximate location X distance away from a GPS location with a \n     * certain bearing from that GPS location.\n     * \n     * It will return an object with the following structure:\n     * {\n     *      lat: <latitude of approximate location>\n     *      long: <longitude of approximate location>\n     * }\n     * \n     * @param {Float} lat The latitude of the GPS location in degrees\n     * @param {Float} long The longitude of the GPS location in degrees\n     * @param {Float} bearing The bearing in degrees\n     * @param {Float} distance The distance in meters\n     * @returns {Object} The approximate location.\n     */\n    calculateDestinationPoint: function(lat, long, bearing, distance){\n        let latInRads = this.convertDegreesToRadians(lat);\n        let longInRads = this.convertDegreesToRadians(long);\n\n        let angularDistance = distance / this.EARTH_RADIUS;\n        let bearingInRads = this.convertDegreesToRadians(bearing);\n\n        let lat2InRads = Math.asin(Math.sin(latInRads) * Math.cos(angularDistance) + \n                        Math.cos(latInRads) * Math.sin(angularDistance) * Math.cos(bearingInRads));\n        let lat2InDegrees = this.convertRadiansToDegrees(lat2InRads);\n\n        let y = Math.sin(bearingInRads) * Math.sin(angularDistance) * Math.cos(latInRads);\n        let x = Math.cos(angularDistance) - Math.sin(latInRads) * Math.sin(lat2InRads);\n        let long2InRads = longInRads + Math.atan2(y, x);\n        \n        \n        let long2InDegrees = this.convertRadiansToDegrees(long2InRads);\n        let normalizedLong2InDegrees = (long2InDegrees + 540) % 360 - 180;\n        \n        return {\n            lat: lat2InDegrees,\n            long: normalizedLong2InDegrees\n        };\n    },\n\n    /**\n     * Computes the distance between two GPS locations. It takes Earth's radius\n     * into account.\n     * @param {Float} lat1 The latitude of the first GPS location in radians\n     * @param {Float} long1 The longitude of the first GPS location in radians\n     * @param {Float} lat2 The latitude of the second GPS location in radians\n     * @param {Float} long2 The longitude of the second GPS location in radians\n     * @returns {Float} The distance between two GPS locations.\n     */\n    calculateDistance: function(lat1, long1, lat2, long2){\n        var dLat = this.convertDegreesToRadians(lat2 - lat1);\n        var dLong = this.convertDegreesToRadians(long2 - long1);\n        var lat1_rads = this.convertDegreesToRadians(lat1);\n        var lat2_rads = this.convertDegreesToRadians(lat2);\n\n        var a = Math.pow(Math.sin(dLat / 2), 2) +\n                Math.pow(Math.sin(dLong / 2), 2) * \n                Math.cos(lat1_rads) * Math.cos(lat2_rads); \n        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n        return this.EARTH_RADIUS * c;\n    }\n};","const GIS = require(\"../utils/Gis\");\n\n/**\n * Returns two indexes, i and i + 1 where stops[i].time <= time && time <= stops[i + 1].time.\n * Pre-condition: stops must contain the following structure:\n *  [{\n *      lat: <latitude of stop in radians>\n *      long: <longitude of stop in radians>\n *      time: <expected time of bus / train to arrive at in seconds after midnight>\n *   }, \n *   ...\n *  ]\n * @param {Object[]} stops A list of stops sorted by time in ascending order\n * @param {Integer} time The time in seconds after midnight\n */\nfunction findBoundaryBetweenTwoStops(stops, time){\n    let left = 0;\n    let right = stops.length;\n\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        let nextMid = mid + 1;\n\n        let stopA = stops[mid];\n        let stopB = stops[nextMid];\n\n        if (stopA.time <= time && time <= stopB.time){\n            return [mid, nextMid];\n        }\n        else if (time < stopA.time){\n            right = mid - 1;\n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    throw new Error(\"Cannot find boundary between two stops!\");\n}\n\n/**\n * Computes the total distance of a path segment from path[startIndex] \n * to path[endIndex] not including path[endIndex]\n * @param {Object[]} path A list of path locations in order\n * @param {*} startIndex The index to the start of a path segment\n * @param {*} endIndex The index to the end of a path segment\n * @returns {Float} The total distance of a path segment\n */\nfunction computeTotalDistanceBetweenPath(path, startIndex, endIndex){\n    let totalDistance = 0;\n    for (let i = startIndex; i < endIndex; i++){\n        let curPathLocation = path[i];\n        let nextPathLocation = path[i + 1];\n\n        let lat1 = curPathLocation.lat;\n        let long1 = curPathLocation.long;\n        let lat2 = nextPathLocation.lat;\n        let long2 = nextPathLocation.long;\n        let curDistance = GIS.calculateDistance(lat1, long1, lat2, long2);\n\n        totalDistance += curDistance;\n    }\n    return totalDistance;\n}\n\n/**\n * Predicts the location in a path segment given the amount already travelled in the path segment.\n * @param {Object[]} path A set of coordinates in sorted form which outlines the path.\n * @param {Integer} startPathIndex The index to the start of a path segment in path[]\n * @param {Integer} endPathIndex The index to the end of a path segment in path[]\n * @param {Float} ratio The current amount of distance already travelled from the start \n *      of the path to the end of the path segment.\n */\nfunction predictLocation(path, startPathIndex, endPathIndex, ratio){\n    let totalDistanceOfPath = computeTotalDistanceBetweenPath(path, startPathIndex, endPathIndex);\n    let distanceToTravel = totalDistanceOfPath * ratio;\n\n    /**\n     * Get the path index \"closestPathIndex\" s.t. the predicted location is between \n     * path[closestPathIndex] and path[closestPathIndex + 1] inclusive.\n     */\n    let closestPathIndex = startPathIndex;\n    while(closestPathIndex < endPathIndex){\n        let curPathLocation = path[closestPathIndex];\n        let nextPathLocation = path[closestPathIndex + 1];\n\n        let lat1 = curPathLocation.lat;\n        let long1 = curPathLocation.long;\n        let lat2 = nextPathLocation.lat;\n        let long2 = nextPathLocation.long;\n        let curDistance = GIS.calculateDistance(lat1, long1, lat2, long2);\n\n        if (distanceToTravel - curDistance < 0){\n            break;\n        }\n        distanceToTravel -= curDistance;\n        closestPathIndex ++;\n    }\n\n    // Get the predicted location between path[closestPathIndex] and path[closestPathIndex + 1]\n    if (closestPathIndex === endPathIndex){\n        return {\n            lat: path[closestPathIndex].lat,\n            long: path[closestPathIndex].long\n        };\n    }\n    else{\n        let closestPath = path[closestPathIndex];\n        let nextPath = path[closestPathIndex + 1];\n\n        let bearing = GIS.computeBearings(nextPath.lat, nextPath.long, closestPath.lat, closestPath.long);\n        return GIS.calculateDestinationPoint(closestPath.lat, closestPath.long, bearing, distanceToTravel);\n    }\n}\n\nfunction getNearestPathLocation(location, path){\n    let curIndex = 0;\n    let minIndex = 0;\n    let maxIndex = 0;\n    let minDistance = Infinity;\n    while (curIndex < path.length){\n        let curPathLocation = path[curIndex];\n        let curDistance = GIS.calculateDistance(location.lat, location.long, curPathLocation.lat, curPathLocation.long);\n\n        if (curDistance < minDistance){\n            minDistance = curDistance;\n            minIndex = curIndex;\n            maxIndex = curIndex;\n        }\n        else if (curDistance == minDistance){\n            maxIndex = curIndex;\n        }\n\n        curIndex ++;\n    }\n    return {\n        minIndex: minIndex,\n        maxIndex: maxIndex\n    };\n}\n\nexport function GetLocationOnPath(stops, path, time){\n    let adjacentStopIndexes = findBoundaryBetweenTwoStops(stops, time);\n    let leftStop = stops[adjacentStopIndexes[0]];\n    let rightStop = stops[adjacentStopIndexes[1]];\n    let startPathIndex = getNearestPathLocation(leftStop, path).minIndex;\n    let endPathIndex = getNearestPathLocation(rightStop, path).maxIndex;\n\n    let ratio = (time - leftStop.time) / (rightStop.time - leftStop.time);\n    let predictedLocation = predictLocation(path, startPathIndex, endPathIndex, ratio);\n\n    return predictedLocation;\n}","import React from \"react\";\nimport \"./MapView.css\";\n\n// Imports for the map\nimport \"ol/ol.css\";\nimport {fromLonLat} from \"ol/proj.js\";\nimport {Map as OlMap, View as OlView} from \"ol\";\nimport {Tile as OlTileLayer, Vector as OlVectorLayer} from \"ol/layer.js\";\nimport OlOSM from \"ol/source/OSM.js\";\n\n// For drawing objects on the map\nimport OlVectorSource from \"ol/source/Vector.js\";\nimport OlGeoJSON from \"ol/format/GeoJSON.js\";\nimport OlStroke from \"ol/style/Stroke\";\nimport OlStyle from \"ol/style/Style\";\nimport OlCircleStyle from \"ol/style/Circle\";\nimport Stroke from \"ol/style/Stroke\";\n\nimport {GetLocationOnPath} from \"../../services/LocationTracker\";\n\n/**\n * A component which displays the map to the user\n * It uses OpenLayers as the map\n */\nclass MapView extends React.Component {\n\n    /**\n     * Constructs the component with initial properties\n     * @param {Object} props Initial properties\n     */\n    constructor(props){\n        super(props);\n        this.olMap = null;\n        this.olPathLayer = null;\n        this.olStopsLayer = null;\n    }\n\n    /**\n     * Creates and returns a new OpenLayers layer\n     * which will display the stops\n     * @returns {OlVectorLayer} Returns a Vector Layer that will display the stops.\n     */\n    createStopsLayer = () => {\n        var stopsStyle = new OlStyle({\n            image: new OlCircleStyle({\n                radius: 5,\n                fill: null,\n                stroke: new Stroke({\n                    color: \"red\",\n                    width: 1\n                })\n            })\n        });\n\n        var stopsStyleFunction = function(feature){\n            return stopsStyle;\n        };\n\n        var stopsLayer = new OlVectorLayer({\n            source: new OlVectorSource(),\n            style: stopsStyleFunction\n        });\n\n        return stopsLayer;\n    }\n\n    /**\n     * Updates the stops layer with new stops.\n     * It will clear the existing stops and render the new stops.\n     * \n     * If this.olStopsLayer is not set, it will not render the new stops.\n     * It will render the path on this.olStopsLayer.\n     * \n     * @param {Object} newStops The new stops\n     */\n    updateStopsLayer = (newStops) => {\n        let stopsGeoJsonObjects = newStops.map(item => {\n            return {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": fromLonLat([item.long, item.lat])\n                }\n            };\n        });\n\n        let geoJsonObject = {\n            \"type\": \"FeatureCollection\",\n            \"crs\": {\n                \"type\": \"name\",\n                \"properties\": {\n                    \"name\": \"EPSG:3857\"\n                }\n            },\n            \"features\": stopsGeoJsonObjects\n        };\n\n        if (this.olStopsLayer){\n            let source = this.olStopsLayer.getSource();\n\n            if (source){\n                source.clear();\n                source.addFeatures((new OlGeoJSON()).readFeatures(geoJsonObject));\n                source.refresh();\n            }\n        }\n    }\n\n    /**\n     * Creates and returns a new OpenLayers layer\n     * which will display the path of the trip\n     * @returns {OlVectorLayer} Returns a Vector Layer that will display the path of the trip.\n     */\n    createPathLayer = () => {\n        var pathStyle = new OlStyle({\n            stroke: new OlStroke({\n                color: \"green\",\n                width: 3\n            })\n        });\n\n        var pathStyleFunction = function(feature) {\n            return pathStyle;\n        };\n\n        var pathLayer = new OlVectorLayer({\n            source: new OlVectorSource(),\n            style: pathStyleFunction\n        });\n\n        return pathLayer;\n    }\n\n    /**\n     * Updates the path layer with a new path.\n     * It will clear the existing path and render the new path.\n     * \n     * If this.olPathLayer is not set, it will not render the new path.\n     * It will render the path on this.olPathLayer.\n     * \n     * @param {Object} newPath The new path\n     */\n    updatePathLayer = (newPath) => {\n        let pathCoordinates = newPath.map(item => {\n            return fromLonLat([item.long, item.lat]);\n        });\n\n        let geoJsonObject = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": pathCoordinates\n            }\n        };\n\n        if (this.olPathLayer){\n            let source = this.olPathLayer.getSource();\n\n            if (source){\n                source.clear();\n                source.addFeature((new OlGeoJSON()).readFeature(geoJsonObject));\n                source.refresh();\n            }\n        }\n    }\n\n    createLiveLocationLayer = () => {\n        var liveLocationStyle = new OlStyle({\n            image: new OlCircleStyle({\n                radius: 10,\n                fill: null,\n                stroke: new Stroke({\n                    color: \"blue\",\n                    width: 2\n                })\n            })\n        });\n        var liveLocationStyleFunction = function(feature) {\n            return liveLocationStyle;\n        };\n\n        var liveLocationLayer = new OlVectorLayer({\n            source: new OlVectorSource(),\n            style: liveLocationStyleFunction\n        });\n\n        return liveLocationLayer;\n    }\n\n    updateLiveLocationLayer = (newLatitude, newLongitude) => {\n        let geoJsonObject = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": fromLonLat([newLongitude, newLatitude])\n            }\n        };\n\n        if (this.olLiveLocationLayer){\n            let source = this.olLiveLocationLayer.getSource();\n\n            if (source){\n                source.clear();\n                source.addFeature((new OlGeoJSON()).readFeature(geoJsonObject));\n                source.refresh();\n            }\n        }\n    }\n\n    /**\n     * This method gets called whenever the HTML elements in this component is already \n     * in the DOM.\n     * \n     * It will create an initial view of the OpenLayers map as well as setting up\n     * the required layers.\n     */\n    componentDidMount(){        \n        // Create the view for the map\n        let initialLatitude = this.props.viewLocation.latitude;\n        let initialLongitude = this.props.viewLocation.longitude;\n        let mapZoom = this.props.zoom;\n        this.olView = new OlView({\n            center: fromLonLat([initialLongitude, initialLatitude]),\n            zoom: mapZoom\n        });\n        console.log(\"initialLatitude: \" + initialLatitude + \" | initialLongitude: \" + initialLongitude);\n\n        this.olPathLayer = this.createPathLayer();\n        this.olStopsLayer = this.createStopsLayer();\n        this.olLiveLocationLayer = this.createLiveLocationLayer();\n\n        // Initialize the map\n        this.olMap = new OlMap({\n            target: \"map\",\n            layers: [\n                new OlTileLayer({\n                    source: new OlOSM()\n                }),\n                this.olPathLayer,\n                this.olStopsLayer,\n                this.olLiveLocationLayer\n            ],\n            loadTilesWhileAnimating: true,\n            view: this.olView\n        });\n    }\n    \n    /**\n     * This method gets called whenever the component updates.\n     * This method will prevent the OpenLayers map from being\n     * deconstructed and re-instantiated and instead update the \n     * stops and the path displayed on the map.\n     * \n     * @param {Object} nextProps The new set of properties\n     * @param {Object} nextState The new set of states\n     */\n    shouldComponentUpdate(nextProps, nextState){\n        if (this.olMap !== null){\n            this.updateDimensions();\n\n            let newViewOptions = {};\n\n            if (this.props.viewLocation !== nextProps.viewLocation){\n                let initialLatitude = nextProps.viewLocation.latitude;\n                let initialLongitude = nextProps.viewLocation.longitude;\n\n                newViewOptions.center = fromLonLat([initialLongitude, initialLatitude]);\n                newViewOptions.duration = 2000;\n\n                console.log(\"initialLatitude: \" + initialLatitude + \" | initialLongitude: \" + initialLongitude);\n            }\n\n            if (this.props.zoom !== nextProps.zoom){\n                newViewOptions.zoom = nextProps.zoom;\n                newViewOptions.duration = 2000;\n            }\n\n            if (newViewOptions !== {}){\n                this.olView.animate(newViewOptions);\n            }\n\n            this.updatePathLayer(nextProps.path);\n            this.updateStopsLayer(nextProps.stops);\n\n            let curLatitude = nextProps.currentLocation.latitude;\n            let curLongitude = nextProps.currentLocation.longitude;\n            this.updateLiveLocationLayer(curLatitude, curLongitude);\n        }\n        return true;\n    }\n\n    /**\n     * This method is called whenever the component's dimensions changes.\n     * This method will re-compute the size for the OpenLayers map.\n     */\n    updateDimensions() {\n\n        // Reason for creating a timeout was described at:\n        // https://gis.stackexchange.com/questions/31409/openlayers-redrawing-map-after-container-resize\n        setTimeout(() => { \n            this.olMap.updateSize();\n        }, 200);\n    }\n\n    /**\n     * This method gets called whenever React wants to re-render the component.\n     */\n    render(){\n        return (<div id=\"map\" className=\"map\"></div>);\n    }\n}\n\nexport default MapView;","\n/**\n * Formats the number of seconds to its most appropriate unit of time.\n * @param {Integer} numSeconds The number of seconds\n */\nexport function getFormattedTime(numSeconds) {\n    let numHrsRemaining = Math.trunc(numSeconds / 3600);\n    numSeconds = numSeconds % 3600;\n    \n    let numMinRemaining = Math.trunc(numSeconds / 60);\n    numSeconds = numSeconds % 60;\n\n    let remainingTimeValue = \"\";\n    let remainingTimeUnit = \"hours\";\n    if (numHrsRemaining >= 1){\n        if (numHrsRemaining === 1 && numMinRemaining === 0){\n            remainingTimeValue = \"1\";\n            remainingTimeUnit = \"hour\";\n        }\n        else{\n            remainingTimeValue = numHrsRemaining + \":\" + Math.trunc(numMinRemaining).toString().padStart(2, \"0\");\n            remainingTimeUnit = \"hours\";\n        }\n    }\n    else if (numMinRemaining >= 1){\n        if (numMinRemaining === 1 && numSeconds === 0){\n            remainingTimeValue = \"1\";\n            remainingTimeUnit = \"minute\";\n        }\n        else{\n            remainingTimeValue = numMinRemaining + \":\" + Math.trunc(numSeconds).toString().padStart(2, \"0\");\n            remainingTimeUnit = \"minutes\";\n        }\n    }\n    else {\n        if (numSeconds === 1){\n            remainingTimeValue = \"1\";\n            remainingTimeUnit = \"second\";\n        }\n        else{\n            remainingTimeValue = numSeconds.toString();\n            remainingTimeUnit = \"seconds\";\n        }\n    }\n\n    return {\n        value: remainingTimeValue,\n        unit: remainingTimeUnit\n    };\n}\n\n/**\n * Returns the number of seconds from midnight a date object \n * @param {Date} dateObject A date object\n */\nexport function getTimeInSeconds(dateObject){\n    let numHrsFromMidnight = dateObject.getHours();\n    let numMinFromHr = dateObject.getMinutes();\n    let numSecFromMin = dateObject.getSeconds();\n    return numSecFromMin + (60 * numMinFromHr) + (3600 * numHrsFromMidnight);\n}","export function getCurrentTime(){\n    return new Date();\n}\n\n","import React from \"react\";\n\nimport { getFormattedTime, getTimeInSeconds } from \"../../services/TimeFormatter\";\nimport \"./RouteDetailsView.css\";\nimport {getCurrentTime} from \"../../services/TimeService\";\n\nclass RouteDetailsView extends React.Component {\n\n    state = {\n        stops: []\n    }\n\n    componentDidMount() {\n        // Set \"prevTime\" to -1 so that it will always pass the if statement on the first run.\n        let prevTime = -1;  \n\n        this.timer = setInterval(() => {\n\n            var numSecAfterMidnight = getTimeInSeconds(getCurrentTime());\n\n            // Update only if the time has changed.\n            if (numSecAfterMidnight > prevTime){\n\n                // Get the stops that did not pass by and calculate its remaining time.\n                let updatedStops = this.props.stops\n                    .filter(item => item.time > numSecAfterMidnight)\n                    .map(item => {\n                        return {\n                            ...item,\n                            remainingTimeInSeconds: item.time - numSecAfterMidnight\n                        }\n                    });\n\n                // Set the current time in seconds to the state\n                this.setState((prevState, props) => {\n                    return {\n                        ...prevState, \n                        stops: updatedStops\n                    };\n                });  \n\n                prevTime = numSecAfterMidnight;\n            }\n        });\n    }\n\n    componentWillUnmount(){\n        clearInterval(this.timer);\n    }\n\n    render(){\n        let stopContainers = this.state.stops.map(item => {\n            let formattedRemainingTime = getFormattedTime(item.remainingTimeInSeconds);\n\n            // Get the class for whether it is selected or not\n            let alarmClassName = \"stop-interaction-button\";\n            if (this.props.alarms[item.ID] !== undefined){\n                alarmClassName += \" stop-interaction-button-selected\";\n            }\n\n            return (\n                <div key={item.ID} className=\"stop-container\">\n                    <div className=\"stop-info-container\">\n                        <div className=\"stop-name\">{item.name}</div>\n\n                        <div className=\"remaining-time\">\n                            <div className=\"remaining-time-value\">{formattedRemainingTime.value}</div>\n                            <div className=\"remaining-time-unit\">{formattedRemainingTime.unit}</div>\n                        </div>\n                    </div>\n                    <div className=\"stop-interactions-container\">\n                        <div className=\"stop-interactions\">\n                            <div className={alarmClassName}\n                                 onClick={e => {\n                                     if (this.props.alarms[item.ID] === undefined){\n                                        this.props.addNewAlarmHandler(item.ID);\n                                     }\n                                     else{\n                                        this.props.removeAlarmHandler(item.ID);\n                                     }\n                                 }}>\n                                Notify me\n                            </div>\t\t\t\t\n                        </div>\n                    </div>\n                </div>\n            );\n        });\n        return (\n            <div>\n                <div className=\"trip-header-details-container\">\n                    <div className=\"trip-header-details\">\n                        <h3 className=\"short-name\">{this.props.tripShortName}</h3>\n                        <p className=\"long-name\">{this.props.tripLongName}</p>\n                    </div>\n                </div>\n                <div className=\"stop-containers-list\">\n                    {stopContainers}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default RouteDetailsView;","import React from \"react\";\nimport \"./RouteChooserPopup.css\";\n\nimport {getCurrentTime} from \"../../services/TimeService\";\n\nclass NearbyTripsChooserPopup extends React.Component {\n\n    handleSubmit = (event) => {\n        event.preventDefault();\n        console.log(\"Hi there!\");\n        console.log(event.target.route.value);\n\n        let selectedTripID = event.target.route.value;\n        console.log(\"I am here!\");\n        if (selectedTripID === \"\"){\n            // Show error message\n        }\n        else{\n            this.props.onSelectRoute(selectedTripID);\n        }\n    }\n\n    render() {\n        let areThereRoutes = this.props.routes.length > 0;\n        let rows = this.props.routes.map((item, index) => {\n            let shortName = item.shortName;\n            let longName = item.longName;\n            let headsign = item.headsign;\n\n            let display = \"\";\n            if (shortName){\n                display += shortName + \" \";\n            }\n            if (headsign){\n                display += headsign + \" \";\n            }\n            if (longName){\n                display += \"(\" + longName + \")\";\n            }\n            display.trim();\n\n            return {\n                ...item,\n                display: display\n            };\n        }).sort((tripA, tripB) => {\n            return tripA.display < tripB.display;\n        }).filter(trip => {\n            return trip.startTime <= getCurrentTime() <= trip.endTime;\n        }).map(item => {\n            let tripID = item.tripID;\n            let display = item.display;\n            \n            return (\n                <div key={tripID}>\n                    <input type=\"radio\" name=\"route\" value={tripID}/>\n                    <div className=\"tripInfo\">{display}</div>\n                </div>\n            );\n\n        });\n\n        return (\n            <div className=\"popup-background\">\n                <div className=\"popup-container\">\n                    <div className=\"popup\">\n                        <div className=\"popup-header\">{\n                            areThereRoutes\n                                ? <div>\n                                    <h3>Which bus / train are you on?</h3>\n                                    <p>\n                                        There are multiple bus / train routes near your area. \n                                        Please select which route you are currently on.\n                                    </p>\n                                  </div>\n                                : <div>\n                                    <h3>There are no busses / trains near you!</h3>\n                                    <p>Are you on a bus / train? If not, this explains why we cannot find your bus / train!</p>\n                                  </div>\n                        }</div>\n                        <form onSubmit={this.handleSubmit}>\n                            <div className=\"popup-contents\">{\n                                areThereRoutes\n                                    ? rows\n                                    : <p>Please wait while we try to determine the busses / trains around you.</p>\n                            }</div>\n                            <div className=\"popup-actions-container\">{\n                                areThereRoutes\n                                    ?  <button className=\"popup-action-button\" type=\"submit\">\n                                        OK\n                                      </button>\n                                    : null\n                            }</div>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default NearbyTripsChooserPopup;","import Axios from \"axios\";\nAxios.defaults.timeout = 180000;\n\nconst TRIPS_LOCATOR_URL = \"https://on-transit-app-api-gateway.herokuapp.com/api/v1/trips\";\nconst TRIP_DETAILS_URL = \"https://on-transit-app-api-gateway.herokuapp.com/api/v1/trips\";\nconst VEHICLES_LOCATOR_URL = \"https://on-transit-app-api-gateway.herokuapp.com/api/v1/vehicles\";\n\nclass OnTransitService {\n\n    async getNearbyTrips(latitude, longitude, time, radius){\n        try{\n            let urlParams = {\n                lat: latitude,\n                long: longitude,\n                time: time,\n                radius: radius\n            };\n            let options = {\n                params: urlParams\n            }\n            let rawData = await Axios.get(TRIPS_LOCATOR_URL, options);\n            console.log(rawData);\n            return rawData.data.data;\n        }\n        catch(error){\n            throw error;\n        }\n    }\n\n    async getTripDetails(tripID){\n        try{\n            let url = TRIP_DETAILS_URL + \"/\" + tripID;\n            let rawData = await Axios.get(url);\n            return rawData.data.data;\n        }\n        catch(error){\n            throw error;\n        }\n    }\n\n    async getNearbyVehicles(latitude, longitude, radius){\n        try{\n            let urlParams = {\n                lat: latitude,\n                long: longitude,\n                radius: radius\n            };\n            let options = {\n                params: urlParams\n            };\n            let rawData = await Axios.get(VEHICLES_LOCATOR_URL, options);\n            return rawData.data.data;\n        }\n        catch(error){\n            throw error;\n        }\n    }\n}\n\nexport default OnTransitService;","\"use strict\";\n\nimport React from \"react\";\nimport \"./end-of-route-popup.css\";\n\nclass EndOfRoutePopup extends React.Component {\n    state = {\n        countdownValue: 5\n    }\n    \n    componentDidMount() {\n        this.countdownInterval = setInterval(() => {\n            if (this.state.countdownValue <= 0){\n                this.props.restartApp();\n            }\n\n            else{\n                this.setState((prevState, props) => {\n                    return {\n                        countdownValue: prevState.countdownValue - 1\n                    };\n                });\n            }\n        }, 1000);\n    }\n\n    componentWillUnmount(){\n        if (this.countdownInterval){\n            clearInterval(this.countdownInterval);\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"popup-background\">\n                <div className=\"popup-container\">\n                    <div className=\"popup\">\n                        <div className=\"popup-header\">\n                            <h3>Which bus / train are you on?</h3>\n                        </div>\n                        <form onSubmit={this.handleSubmit}>\n                            <div className=\"popup-contents\">\n                                <p>The bus or train has completed its trip! You will need to select a different trip.</p>\n\t\t\t\t\t            <p>You will be redirected in <span>{this.state.countdownValue} seconds</span>.</p>\n                            </div>\n                            <div className=\"popup-actions-container\">\n                            </div>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default EndOfRoutePopup;","import React from 'react';\nimport { ToastContainer, toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\n\nimport \"./App.css\";\nimport Map from \"../map-view/MapView\";\nimport RouteDetailsView from '../route-details-view/RouteDetailsView.js';\nimport RouteChooserPopup from \"../route-chooser-popup/RouteChooserPopup\";\nimport { getFormattedTime, getTimeInSeconds } from \"../../services/TimeFormatter\";\n\nimport {getCurrentTime} from \"../../services/TimeService\";\n\nimport MockedOnTransitService from '../../services/OnTransitService.js';\n\nimport {GetLocationOnPath} from \"../../services/LocationTracker\";\nimport EndOfRoutePopup from '../end-of-route-popup/end-of-route-popup';\n\nclass App extends React.Component {\n    state = {\n        displayRouteChoices: false,\n        displayRouteDetails: false,\n        displayEndOfRouteMessage: false,\n        mapZoom: 3,\n        curLocation: {\n            latitude: 43.554028,\n            longitude: -79.722099\n        },\n        initLocation: {\n            latitude: 0,\n            longitude: 0\n        },\n        possibleRoutes: [],\n        tripDetailsID: null,\n        tripDetails: {\n            shortName: null,\n            longName: null,\n            path: [],\n            stops: []\n        },\n        alarms: {}\n    }\n\n    async componentDidMount(){\n        this.onTransitService = new MockedOnTransitService();\t\n        \n        \n        if (!(\"Notification\" in window)){\n            alert(\"Notifications are not supported in this browser!\");\n        }\n\n        Notification.requestPermission();\n\n        this.startGeolocationWatch();\n        this.startAlarmWatch();\n    }\n\n    restartApp = () => {\n        this.componentWillUnmount();\n        this.setState((prevState, props) => {\n            return {\n                displayRouteChoices: false,\n                displayRouteDetails: false,\n                displayEndOfRouteMessage: false,\n                mapZoom: 3,\n                curLocation: {\n                    latitude: 43.554028,\n                    longitude: -79.722099\n                },\n                initLocation: {\n                    latitude: 0,\n                    longitude: 0\n                },\n                possibleRoutes: [],\n                tripDetailsID: null,\n                tripDetails: {\n                    shortName: null,\n                    longName: null,\n                    path: [],\n                    stops: []\n                },\n                alarms: {}\n            };\n        });\n        this.componentDidMount();\n    }\n\n    startGeolocationWatch = () => {\n        // Initialize and watch the location\n        let geolocationOptions = {\n            enableHighAccuracy: true,\n            timeout: Infinity,\n            maximumAge: 0\n        };\n\n        if (navigator.geolocation){\n            this.geolocationWatch = navigator.geolocation.watchPosition(\n                this.onLocationChangedSuccess, this.onLocationChangedError, geolocationOptions);\n        }\n    };\n\n    startPredictedLocationWatch = () => {\n        if (this.state.tripDetails.stops.length > 1){\n            this.liveLocationWatch = setInterval(() => {\n                let stops = this.state.tripDetails.stops;\n                let path = this.state.tripDetails.path;\n                let currentTimeInSeconds = getTimeInSeconds(getCurrentTime());\n                let lastStop = stops[stops.length - 1];\n\n                if (currentTimeInSeconds >= lastStop.time){\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            displayEndOfRouteMessage: true,\n                            displayRouteDetails: false\n                        };\n                    });\n                }\n                else{\n                    let predictedLocation = GetLocationOnPath(stops, path, currentTimeInSeconds);\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            curLocation: {\n                                latitude: predictedLocation.lat,\n                                longitude: predictedLocation.long\n                            }\n                        };\n                    });\n                }\n            });\n        }\n    }\n\n    startAlarmWatch = () => {\n        this.alarmInterval = setInterval(() => {\n            var curTimeInSeconds = getTimeInSeconds(getCurrentTime());\n\n            Object.keys(this.state.alarms).forEach(stopID => {\n                // Get the stop detail for that stopID\n                let stopDetails = this.state.tripDetails.stops.find(stop => {\n                    return stop.ID == stopID;\n                });\n\n                if (stopDetails !== undefined){\n                    let alarmDetails = this.state.alarms[stopID];\n                    let remainingTimeLeft = stopDetails.time - curTimeInSeconds;\n\n                    if (remainingTimeLeft < alarmDetails.minRemainingTimeLeft && !alarmDetails.isDispatched){\n                        console.log(\"RING RING RING!!!\");\n                        this.dispatchAlarm(stopDetails);\n                        this.removeAlarm(stopID);\n                    }\n                }\n                else{\n                    throw new Error(\"Inconsistency with stop ID \" + stopID + \" and trip details!\");\n                }\n            });\n        });\n    }\n\n    stopAlarmWatch = () => {\n        if (this.alarmInterval){\n            clearInterval(this.alarmInterval);\n        }\n    }\n\n    stopLiveLocationWatch = () => {\n        if (this.liveLocationWatch){\n            clearInterval(this.liveLocationWatch);\n        }\n    }\n\n    stopGeolocationWatch = () => {\n        navigator.geolocation.clearWatch(this.geolocationWatch);\n    }\n\n    componentWillUnmount(){\n        this.stopAlarmWatch();\n        this.stopLiveLocationWatch();\n        this.stopGeolocationWatch();       \n    }\n\n    onLocationChangedSuccess = (position) => {\n        let latitude = position.coords.latitude;\n        let longitude = position.coords.longitude;\n        let radius = position.coords.accuracy;\n        let time = new Date().toLocaleTimeString();\n\n        console.log(this.state);\n\n        if (this.state.tripDetailsID === null){\n            console.log(\"heee\");\n\n            // Get the nearby trips and vehicles\n            let nearbyTripsPromise = this.onTransitService.getNearbyTrips(latitude, longitude, time, radius);\n            let nearbyVehiclesPromise = this.onTransitService.getNearbyVehicles(latitude, longitude, radius);\n            \n            Promise.all([nearbyTripsPromise, nearbyVehiclesPromise])\n                .then(values => {    \n                    \n                    if (this.state.tripDetailsID !== null){\n                        return;\n                    }\n\n                    console.log(Object.keys(values[0].tripIDs));\n                    \n                    let nearbyTrips = Object.keys(values[0].tripIDs).map(key => {\n                        let tripID = key;\n                        let tripDetails = values[0].tripIDs[tripID];\n                        return {\n                            ...tripDetails, \n                            tripID: tripID\n                        };\n                    });\n\n                    console.log(nearbyTrips);\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            displayRouteChoices: true,\n                            possibleRoutes: nearbyTrips,\n                            curLocation: {\n                                latitude: latitude,\n                                longitude: longitude\n                            }\n                        };\n                    });\n\n                    \n                })\n                .catch(errors => {\n                    console.log(errors);\n                });\n        }\n    }\n\n    onLocationChangedError = (error) => {\n        console.log(\"ERROR!\");\n        console.log(error);\n    }\n\n    selectRoute = (tripID) => {\n        console.log(\"Selected Trip ID: \" + tripID);\n        if (this.state.tripDetailsID !== tripID){\n            this.onTransitService.getTripDetails(tripID)\n                .then(results => {\n\n                    // Set the ID of results to their index\n                    results.stops = results.stops.map((item, index) => {\n                        return {\n                            ...item,\n                            ID: index\n                        };\n                    });\n\n                    // Get the midpoint between all the path locations\n                    let sumOfAllPathLatitudes = results.path.reduce((curSum, item) => curSum + item.lat, 0);\n                    let sumOfAllPathLongitudes = results.path.reduce((curSum, item) => curSum + item.long, 0);\n                    let midPathLatitude = sumOfAllPathLatitudes / results.path.length;\n                    let midPathLongitude = sumOfAllPathLongitudes / results.path.length;\n\n                    this.setState((prevState, props) => {\n                        return {\n                            ...prevState,\n                            initLocation: {\n                                latitude: midPathLatitude,\n                                longitude: midPathLongitude\n                            },\n                            tripDetailsID: tripID,\n                            displayRouteDetails: true,\n                            displayRouteChoices: false,\n                            tripDetails: results,\n                            mapZoom: 13,\n                            alarms: {}\n                        };\n                    }, () => {\n                        this.startPredictedLocationWatch();\n                    });\n                })\n                .catch(error => {\n                    console.log(error);\n                });\n        }\n    }\n\n    addNewAlarm = (stopID) => {\n\n        if (this.state.tripDetails.stops[stopID.toString()]){\n            this.setState((prevState, props) => {\n                let newAlarms = prevState.alarms;\n                newAlarms[stopID] = { \n                    minRemainingTimeLeft: 300, //<- 300 seconds is 5 minutes\n                    isDispatched: false\n                }; \n\n                // Display a toast message to the user that an alarm is added.\n                let stopDetails = this.state.tripDetails.stops[stopID.toString()];\n                let toastMessage = \"You will be notified 5 minutes before reaching \" + stopDetails.name;\n                toast(toastMessage, {\n                    position: toast.POSITION.BOTTOM_CENTER\n                });\n                console.log(toastMessage);\n\n                return {\n                    ...prevState,\n                    alarms: newAlarms\n                };\n            });\t\t\t\n        }\n        else{\n            throw new Error(\"Inconsistencies with stopID \" + stopID + \" and this.state.tripDetails.stops\");\n        }\n    }\n\n    removeAlarm = (stopID) => {\n\n        this.setState((prevState, props) => {\n            delete prevState.alarms[stopID.toString()];\n\n            // Display a toast message to the user that the notification is removed\n            let stopDetails = this.state.tripDetails.stops[stopID.toString()];\n            let toastMessage = \"Removed notification for stop \" + stopDetails.name;\n            toast(toastMessage, {\n                position: toast.POSITION.BOTTOM_CENTER\n            });\n\n            console.log(toastMessage);\n\n            return prevState;\n        });\n        \n        console.log(\"Removed alarm \" + stopID);\n    }\n\n    dispatchNotification = (message, timeBeforeClosingNotification) => {\n        // Notify the user via Web Notifications\n        Notification.requestPermission()\n            .then((permission) => {\n                if (permission !== \"granted\"){\n                    throw new Error(\"No access!\");\n                }\n            })\n            .then(() => {\n                console.log(\"We have access here!\");\n                let notification = new Notification(message);\n\n                // Close the notification after 10 seconds\n                setTimeout(() => {\n                    notification.close();\n                }, timeBeforeClosingNotification);\n            })\n            .catch(error => {\n                console.log(\"We have no access here!\");\n            });\n    }\n\n    dispatchAlarm = (stopDetails) => {\n        // let curTimeInSeconds = getTimeInSeconds(new Date());\n        let curTimeInSeconds = getTimeInSeconds(getCurrentTime());\n\n        let numSecondsRemaining = stopDetails.time - curTimeInSeconds;\n        let formattedTimeRemaining = getFormattedTime(numSecondsRemaining);\n        let stopID = stopDetails.ID;\n\n        let notificationContent = \"You are \" +  \n            formattedTimeRemaining.value + \" \" + \n            formattedTimeRemaining.unit + \" away from \" + \n            stopDetails.name;\n\n        this.dispatchNotification(notificationContent, 10000);\n\n        this.setState((prevState, props) => {\n            let newAlarms = prevState.alarms;\n            newAlarms[stopID.toString()].isDispatched = true;\n\n            return {\n                ...prevState,\n                alarms: newAlarms\n            };\n        });\n    }\n \n    render() {\n        return (\n            <div className=\"app-container\">\n                {\n                    this.state.displayRouteDetails\n                        ? <div className=\"left-panel\">\n                            <RouteDetailsView\n                                tripShortName={this.state.tripDetails.shortName}\n                                tripLongName={this.state.tripDetails.longName}\n                                stops={this.state.tripDetails.stops}\n                                alarms={this.state.alarms}\n                                addNewAlarmHandler={this.addNewAlarm}\n                                removeAlarmHandler={this.removeAlarm}/>\n                          </div>\n                        : null\n                }\n                <div className=\"right-panel\">\n                    <Map viewLocation={this.state.initLocation}\n                         zoom={this.state.mapZoom}\n                         currentLocation={this.state.curLocation}\n                         path={this.state.tripDetails.path}\n                         stops={this.state.tripDetails.stops} />\n                </div>\t\t\t\t\n                {\n                    this.state.displayRouteChoices \n                        ? <RouteChooserPopup \n                            routes={this.state.possibleRoutes}\n                            onSelectRoute={this.selectRoute}/> \n                        : null \n                }\t\n                {\n                    this.state.displayEndOfRouteMessage\n                        ? <EndOfRoutePopup restartApp={this.restartApp}/>\n                        : null\n                }\n                <ToastContainer />\t\t\n            </div>\n        );\n    }\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app/App';\n\nReactDOM.render(\n    <App/>, \n    document.getElementById('root')\n);"],"sourceRoot":""}